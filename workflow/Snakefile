#Get input directory from config
input_dir = config["input_dir"]
if not input_dir.endswith("/"):
    input_dir += "/"

#Fetch and store all *.fastq.gz files in the input directory
FASTQ, = glob_wildcards(input_dir+"genomic_data/pacbio/{sample,[^/]+}.fastq.gz")
HIC, = glob_wildcards(input_dir+"genomic_data/hic/{sample}_1.fastq.gz")
HAPS = ["hap1", "hap2"]

print()
print(f"Specified Input Directory: {input_dir}")
print(f"Identified PacBio files: {FASTQ}")
print(f"Identified HiC files: {HIC}")
print()

#Define rules that do not need to be submitted to the cluster
localrules: concatenate_filtered_reads, print_versions

#Summary rule to run full pipeline (pre-assembly, assembly, scaffolding)
rule all:
    input:
        expand("results/pre_assembly/genomescope/genomescope_ploidy{ploidy}.out", ploidy=config["GS_ploidy_range"]),
        expand("results/pre_assembly/smudgeplot/ploidy{ploidy}_smudgeplot.png", ploidy=config["smudge_ploidy"]),
        expand("results/assembly/busco_assembly.hic.{hap}.p_ctg_{lineage}", lineage=config["busco_lineage"], hap=HAPS),
        expand("results/scaffolding/busco_{hap}_scaffolds_final_{lineage}", lineage=config["busco_lineage"], hap=HAPS),
        expand("results/decontamination/{hap}/{hap}_scaffolds_final.decon.fasta", hap=HAPS),
        "software_versions.txt"

#Summary rule to run all pre-assembly steps
rule pre_assembly:
    input:
        expand("results/pre_assembly/genomescope/genomescope_ploidy{ploidy}.out", ploidy=config["GS_ploidy_range"]),
        expand("results/pre_assembly/smudgeplot/ploidy{ploidy}_smudgeplot.png", ploidy=config["smudge_ploidy"]),
        "software_versions.txt"

#General rule for running only primary assembly and busco
rule assembly:
    input:
        expand("results/assembly/busco_assembly.hic.{hap}.p_ctg_{lineage}", lineage=config["busco_lineage"], hap=HAPS),
        "software_versions.txt"
        
#General rule for generated the scaffolded haplotype assemblies (withouth pre-assembly) and busco
rule scaffolding:
    input:
        expand("results/assembly/busco_assembly.hic.{hap}.p_ctg_{lineage}", lineage=config["busco_lineage"], hap=HAPS),
        expand("results/scaffolding/busco_{hap}_scaffolds_final_{lineage}", lineage=config["busco_lineage"], hap=HAPS),
        "software_versions.txt"

#General rule for generationg a decontaminated assembly, but without running busco
rule decontamination:
    input:
        expand("results/decontamination/{hap}/{hap}_scaffolds_final.decon.fasta", hap=HAPS),
        "software_versions.txt"

#Filter PacBio HiFi reads
rule hifiadapterfilt:
    output:
        expand(input_dir+"genomic_data/pacbio/filtered/{sample}.filt.fastq.gz", sample=FASTQ)
    input:
        expand(input_dir+"genomic_data/pacbio/{sample}.fastq.gz", sample=FASTQ)
    resources:
        ntasks = config["adapterfilt_threads"]
    params:
        threads = config["adapterfilt_threads"],
        installdir = config["adapterfilt_install_dir"],
        input_dir = input_dir
    shell:
        r"""
        export PATH={params.installdir}/DB:{params.installdir}:$PATH
        cd {params.input_dir}/genomic_data/pacbio/
        mkdir -p temp
        export TMPDIR=./temp
        pbadapterfilt.sh \
            -t {params.threads} \
            -o filtered
        rm -r -f ./temp
        """

#Count k-mers for genomescope and smudgeplot
rule count_kmers:
    output:
        "results/pre_assembly/reads.histo"
    input:
        expand(input_dir+"genomic_data/pacbio/{sample}.fastq.gz", sample=FASTQ)
    resources:
        ntasks = config["KMC_t"]
    params:
        k = config["KMC_k"],
        t = config["KMC_t"],
        m = config["KMC_m"],
        ci = config["KMC_ci"],
        cx = config["KMC_cx"],
        cs = config["KMC_cs"],
        kmc_path = config["KMC_path"]
    shell:
        r"""
        mkdir -p results/pre_assembly/tmp
        ls {input} > FILES
        export PATH={params.kmc_path}/bin:$PATH
        kmc \
            -k{params.k} \
            -t{params.t} \
            -m{params.m} \
            -ci{params.ci} \
            -cs{params.cs} \
            @FILES \
            results/pre_assembly/reads \
            results/pre_assembly/tmp
        kmc_tools transform \
            results/pre_assembly/reads \
            histogram \
            results/pre_assembly/reads.histo \
            -cx{params.cx}
        rm -r -f results/pre_assembly/tmp FILES
        """

#Run Genomescope
rule genomescope:
    output:
        expand("results/pre_assembly/genomescope/genomescope_ploidy{ploidy}.out", ploidy=config["GS_ploidy_range"])
    input:
        "results/pre_assembly/reads.histo"
    params:
        ploidy_range = config["GS_ploidy_range"],
        k = config["KMC_k"]
    shell:
        r"""
        for ploidy in {params.ploidy_range} 
            do genomescope2 \
                -i {input} \
                -o results/pre_assembly/genomescope/output_ploidy$ploidy \
                -k {params.k} \
                -p $ploidy \
                1> results/pre_assembly/genomescope/genomescope_ploidy${{ploidy}}.out \
                2> results/pre_assembly/genomescope/genomescope_ploidy${{ploidy}}.err
        done
        """

#Run Smudgeplot
rule smudgeplot:
    output:
        expand("results/pre_assembly/smudgeplot/ploidy{ploidy}_smudgeplot.png", ploidy=config["smudge_ploidy"]),
    input:
        "results/pre_assembly/reads.histo"
    params:
        ploidy = config["smudge_ploidy"],
        kmc_path = config["KMC_path"],
        k = config["KMC_k"],
    shell:
        r"""
        L=$(smudgeplot.py cutoff {input} L)
        U=$(smudgeplot.py cutoff {input} U)
        export PATH={params.kmc_path}/bin:$PATH
        kmc_tools transform \
            results/pre_assembly/reads \
            -ci$L \
            -cx$U \
            reduce \
            results/pre_assembly/smudgeplot/kmcdb_L"$L"_U"$U"
        smudge_pairs \
            results/pre_assembly/smudgeplot/kmcdb_L"$L"_U"$U" \
            results/pre_assembly/smudgeplot/kmcdb_L"$L"_U"$U"_coverages.tsv \
            results/pre_assembly/smudgeplot/kmcdb_L"$L"_U"$U"_pairs.tsv \
            > results/pre_assembly/smudgeplot/kmcdb_L"$L"_U"$U"_familysizes.tsv
        smudgeplot.py plot \
            results/pre_assembly/smudgeplot/kmcdb_L"$L"_U"$U"_coverages.tsv \
            -o results/pre_assembly/smudgeplot/ploidy{params.ploidy} \
            -k {params.k}
        """

#Concatenate all filtered reads for assembly
rule concatenate_filtered_reads:
    output:
        input_dir+"genomic_data/pacbio/filtered/concat.filt.fastq.gz"
    input:
        expand(input_dir+"genomic_data/pacbio/filtered/{sample}.filt.fastq.gz", sample=FASTQ)
    shell:
        "cat {input} > {output}"

#Perform genome assembly with hifiasm using pacbio reads and hic reads
rule assembly_hifiams:
    output:
        hap1 = "results/assembly/assembly.hic.hap1.p_ctg.fa",
        hap2 = "results/assembly/assembly.hic.hap2.p_ctg.fa"
    input:
        pacbio = input_dir+"genomic_data/pacbio/filtered/concat.filt.fastq.gz",
        hicF = expand(input_dir+"genomic_data/hic/{hic}_1.fastq.gz", hic=HIC),
        hicR = expand(input_dir+"genomic_data/hic/{hic}_2.fastq.gz", hic=HIC)
    resources:
        time = config["hifiasm_cluster_time"],
        mem_per_cpu = config["hifiasm_mem_per_cpu"],
        ntasks = config["hifiasm_threads"]
    params:
        indir = input_dir+"genomic_data/",
        threads = config["hifiasm_threads"],
        h1 = expand("hic/{hic}_1.fastq.gz", hic=HIC),
        h2 = expand("hic/{hic}_2.fastq.gz", hic=HIC)
    shell:
        r"""
        export CWD=$PWD
        cd {params.indir}
        hifiasm \
            -o assembly \
            -t{params.threads} \
            --h1 {params.h1} \
            --h2 {params.h2} \
            pacbio/filtered/concat.filt.fastq.gz
        mv assembly.* $CWD/results/assembly
        awk '/^S/{{print ">"$2"\n"$3}}' $CWD/results/assembly/assembly.hic.hap1.p_ctg.gfa \
            | fold > $CWD/{output.hap1}
        awk '/^S/{{print ">"$2"\n"$3}}' $CWD/results/assembly/assembly.hic.hap2.p_ctg.gfa \
            | fold > $CWD/{output.hap2}
        """


#Run busco on assembly
rule busco:
    output:
        directory(expand("results/{{dir}}/busco_{{assembly}}_{lineage}", lineage=config["busco_lineage"]))
    input:
        assembly = "results/{dir}/{assembly}.fa",
        busco = expand("{busco_db_dir}/{lineage}_odb10", busco_db_dir=config["busco_db_dir"], lineage=config["busco_lineage"])
    resources:
        mem_per_cpu = config["busco_mem"],
        ntasks = config["busco_threads"]
    params:
        lineage = config["busco_lineage"],
        threads = config["busco_threads"]
    shell:
        r"""
        busco \
            -i {input.assembly} \
            -l {input.busco} \
            -c {params.threads} \
            -m genome \
            --offline \
            --out_path results/{wildcards.dir} \
            -o busco_{wildcards.assembly}_{params.lineage} \
            --download_path /tmp
        """

#Create Meryl Database
rule create_meryl_db:
    output:
        directory("results/scaffolding/meryl/assembly.hic.{hap}.p_ctg.meryl")
    input:
        "results/assembly/assembly.hic.{hap}.p_ctg.fa"
    resources:
        ntasks = config["meryl_threads"]
    params:
        k = config["meryl_k"],
        t = config["meryl_threads"],
        m = config["meryl_memory"],
    shell:
        r"""
        meryl \
            k={params.k} \
            threads={params.t} \
            memory={params.m} \
            count \
            output {output} \
            {input}
        """
        
#Run meryl for filtering Hi-C reads before scaffolding
rule meryl_filter:
    output:
        hicFwoH1 = "results/scaffolding/meryl/hicF_hap2.fastq.gz",
        hicRwoH1 = "results/scaffolding/meryl/hicR_hap2.fastq.gz",
        hicFwoH2 = "results/scaffolding/meryl/hicF_hap1.fastq.gz",
        hicRwoH2 = "results/scaffolding/meryl/hicR_hap1.fastq.gz"
    input:
        hicF = expand(input_dir+"genomic_data/hic/{hic}_1.fastq.gz", hic=HIC),
        hicR = expand(input_dir+"genomic_data/hic/{hic}_2.fastq.gz", hic=HIC),
        meryl_hap1 = "results/scaffolding/meryl/assembly.hic.hap1.p_ctg.meryl",
        meryl_hap2 = "results/scaffolding/meryl/assembly.hic.hap2.p_ctg.meryl"
    resources:
        ntasks = config["meryl_threads"]
    shell:
        r"""
        meryl difference \
            {input.meryl_hap1} \
            {input.meryl_hap2} \
            output results/scaffolding/meryl/only_hap1.meryl
        meryl difference \
            {input.meryl_hap2} \
            {input.meryl_hap1} \
            output results/scaffolding/meryl/only_hap2.meryl
        meryl-lookup \
            -exclude \
            -sequence {input.hicF} {input.hicR} \
            -mers results/scaffolding/meryl/only_hap1.meryl \
            -output {output.hicFwoH1} {output.hicRwoH1}
        meryl-lookup \
            -exclude \
            -sequence {input.hicF} {input.hicR} \
            -mers results/scaffolding/meryl/only_hap2.meryl \
            -output {output.hicFwoH2} {output.hicRwoH2}
        """

#Prepare filtered Hi-C reads for scaffolding
rule prepare_hic:
    output:
        "results/scaffolding/{hap}_hic_markdup.sort_n.bam"
    input:
        assembly = "results/assembly/assembly.hic.{hap}.p_ctg.fa",
        hicF = "results/scaffolding/meryl/hicF_{hap}.fastq.gz",
        hicR = "results/scaffolding/meryl/hicR_{hap}.fastq.gz"
    resources:
        ntasks = config["yahs_threads"],
    params:
        t = config["yahs_threads"],
    shell:
        r"""
        bwa index {input.assembly}
        samtools faidx {input.assembly}
        bwa mem \
            -t {params.t} \
            -R '@RG\tSM:{wildcards.hap}\tID:{wildcards.hap}' \
            -5SPM \
            {input.assembly} {input.hicF} {input.hicR} \
        | samtools view -buS - \
            > results/scaffolding/{wildcards.hap}_mapping.bam
        samtools sort \
            -@{params.t} \
            -n \
            -T results/scaffolding/{wildcards.hap}_tmp_n \
            -O bam \
            results/scaffolding/{wildcards.hap}_mapping.bam \
        | samtools fixmate -mr - - \
            > results/scaffolding/{wildcards.hap}_mapping.fixmate.bam
        samtools sort \
            -@{params.t} \
            -T results/scaffolding/{wildcards.hap}_hic_tmp \
            -O bam \
            results/scaffolding/{wildcards.hap}_mapping.fixmate.bam \
        | samtools markdup -rsS - - \
            2> results/scaffolding/{wildcards.hap}_hic_markdup.stats \
            > results/scaffolding/{wildcards.hap}_mapping.markdup.bam
        samtools sort \
            -@{params.t} \
            -n \
            -T results/scaffolding/{wildcards.hap}_temp_n \
            -O bam results/scaffolding/{wildcards.hap}_mapping.markdup.bam \
            > {output}
        if [ -f {output} ]; then
            rm results/scaffolding/{wildcards.hap}_mapping.bam \
                results/scaffolding/{wildcards.hap}_mapping.fixmate.bam \
                results/scaffolding/{wildcards.hap}_mapping.markdup.bam
        fi
        """

#Run scaffolding with yahs
rule scaffold_hap:
    output:
        "results/scaffolding/{hap}_scaffolds_final.fa"
    input:
        assembly = "results/assembly/assembly.hic.{hap}.p_ctg.fa",
        bamfile = "results/scaffolding/{hap}_hic_markdup.sort_n.bam"
    resources:
        ntasks = config["yahs_threads"],
        time = config["yahs_cluster_time"]
    shell:
        r"""
        yahs {input.assembly} {input.bamfile} \
            -o results/scaffolding/{wildcards.hap} \
            1> results/scaffolding/yahs_{wildcards.hap}.out \
            2> results/scaffolding/yahs_{wildcards.hap}.err
        gfastats {output} \
            > results/scaffolding/{wildcards.hap}_scaffolds_final.stats
        """
 
#Remove adaptors and vector contamination
rule fcs_adaptor:
    output:
        "results/decontamination/{hap}/{hap}_scaffolds_final.clean.fa"
    input:
        "results/scaffolding/{hap}_scaffolds_final.fa"
    resources:
        time = config["fcs_adaptor_time"],
        mem_per_cpu = config["fcs_adaptor_mem"],
    params:
        fcs_path = config["fcs_path"],
        fcs_image = config["fcs_adaptor_image"]
    shell:
        r"""
        mkdir -p results/decontamination/{wildcards.hap}/adaptor_output
        bash {params.fcs_path}/run_fcsadaptor.sh \
            --fasta-input {input} \
            --output-dir results/decontamination/{wildcards.hap}/adaptor_output \
            --euk \
            --container-engine singularity \
            --image {params.fcs_path}/fcs-adaptor.sif
        sed 's/lcl|/clean/g' \
            results/decontamination/{wildcards.hap}/adaptor_output/cleaned_sequences/{wildcards.hap}_scaffolds_final.fa > {output}
        """
 
 #Run decontamination pipeline
rule fcs_gx:
    output:
        "results/decontamination/{hap}/{hap}_scaffolds_final.decon.fasta"
    input:
        "results/decontamination/{hap}/{hap}_scaffolds_final.clean.fa"
    resources:
        time = config["fcs_gx_time"],
        mem_per_cpu = config["fcs_gx_mem"],
        partition = config["fcs_gx_partition"],
        ntasks = config["fcs_threads"]
    params:
        fcs_path = config["fcs_path"],
        fcs_threads = config["fcs_threads"],
        fcs_image = config["fcs_gx_image"],
        fcs_db = config["fcs_gx_db"],
        taxid = config["taxid"]
    shell:
        r"""
        mkdir -p results/decontamination/{wildcards.hap}/gx_output
        echo "GX_NUM_CORES={params.fcs_threads}" > results/decontamination/{wildcards.hap}/env.txt
        python3 {params.fcs_path}/fcs.py \
            --image {params.fcs_image} \
            screen genome \
            --fasta {input} \
            --out-dir results/decontamination/{wildcards.hap}/gx_output \
            --gx-db {params.fcs_db} \
            --tax-id {params.taxid}
        cat {input} \
        | python3 {params.fcs_path}/fcs.py \
            --image={params.fcs_image} \
            clean genome \
            --action-report results/decontamination/{wildcards.hap}/gx_output/*.fcs_gx_report.txt \
            --output {output} \
            --contam-fasta-out results/decontamination/{wildcards.hap}/contam.fasta
        """

#Print software versions to file and copy slurm logs to output directory
rule print_versions:
    output:
        "software_versions.txt"
    params:
        kmc_path = config["KMC_path"],
        hifiadapterfilt = config["adapterfilt_install_dir"],
        fcs_path = config["fcs_path"]
    shell:
        r"""
        printf "Conda software versions:\n" > {output}
        conda list -e | grep -v "^#" >> {output}
        printf "\nOther software versions:\n" >> {output}
        printf "KMC version:\t" >> {output}
        {params.kmc_path}/bin/kmc --version | head -n 1 >> {output}
        printf "\nHiFi Adapterfilt version:\t" >> {output}
        bash {params.hifiadapterfilt}/hifiadapterfilt.sh --version >> {output}
        printf "\nNCBI FCS versions:\n" >> {output}
        printf "fcsadaptor:\t" >> {output}
        cat {params.fcs_path}/run_fcsadaptor.sh | grep "^DEFAULT_VERSION" >> {output}
        printf "fcs.py:\t" >> {output}
        cat {params.fcs_path}/fcs.py | grep "^DEFAULT_VERSION" >> {output}
        """

